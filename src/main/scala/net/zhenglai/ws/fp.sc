
/*
 pure functions - functions that have no side effects(Throwing an exception or halting with an error,  Printing to the console or reading user input,  Drawing on the screen)

functional programming is a restriction on how we write programs, but not on what programs we can express

Because of their MODULARITY, pure functions are easier to test, reuse, parallelize, generalize, and reason about.

 => Two important concepts—referential transparency and the substitution model.

Functional programming is often promoted first as a way to do concurrency. However, I've found it to be more fundamentally useful as a way to decompose programming problems.

Functional programming is often promoted first as a way to do concurrency. However, I've found it to be more fundamentally useful as a way to decompose programming problems.


A pure function is modular and composable because it separates the logic of the computation itself from “what to do with the result” and “how to obtain the input”; it’s a black box


Polymorphic functions: abstracting over types
 */


/*
It's Not "Just About Finger Typing"

Scala removes as much of the overhead (and mental load) as possible, so you can express higher-order concepts as quickly as you can type them. I was amazed to discover that in many cases, Scala is even more succinct than Python.
 */


